use std::{
    fmt::{self, Display, Formatter},
    fs,
    path::Path,
};

use log::debug;
use serde::Deserialize;
use serde_derive::{Deserialize, Serialize};
use serde_ini::{Deserializer, Parser};

use crate::common::config::{Config, User};

#[derive(Deserialize, Debug)]
pub enum ENodeMessage {
    CreatePeer = 0,
    RemovePeer = 1,
    CreatePeerResponse = 2,
    RemovePeerResponse = 3,
    RequestTunnel = 4,
    RequestTunnelResponse = 5,
}

impl Into<u8> for ENodeMessage {
    fn into(self) -> u8 {
        self as u8
    }
}

impl From<u8> for ENodeMessage {
    fn from(v: u8) -> Self {
        match v {
            0 => ENodeMessage::CreatePeer,
            1 => ENodeMessage::RemovePeer,
            2 => ENodeMessage::CreatePeerResponse,
            3 => ENodeMessage::RemovePeerResponse,
            4 => ENodeMessage::RequestTunnel,
            5 => ENodeMessage::RequestTunnelResponse,
            _ => panic!("Invalid Packet Type"),
        }
    }
}

#[derive(Deserialize, Debug)]
pub struct CreatePeer {
    #[serde(rename = "userId")]
    pub user_id: String,
}

#[derive(Serialize, Debug)]
pub struct CreatePeerResponse {
    pub ipv4: String,
    #[serde(rename = "privateKey")]
    pub private_key: String,
    #[serde(rename = "publicKey")]
    pub public_key: String,
    #[serde(rename = "userId")]
    pub user_id: String,
}

#[derive(Serialize, Debug)]
pub struct RemovePeerResponse {
    #[serde(rename = "userId")]
    pub user_id: String,
}

#[derive(Serialize, Debug)]
pub struct RequestTunnel {
    pub ipv4: String,
    #[serde(rename = "publicKey")]
    pub public_key: String,
    #[serde(rename = "dstPort")]
    pub dst_port: u16,
    #[serde(rename = "srcPort")]
    pub src_port: u16,
    #[serde(rename = "userRules")]
    pub user_rules: Vec<User>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct Peer {
    pub ipv4: String,
    #[serde(rename = "privateKey")]
    pub private_key: String,
    #[serde(rename = "publicKey")]
    pub public_key: String,
    #[serde(rename = "userId")]
    pub user_id: String,
}

#[derive(Deserialize, Debug)]
pub struct RequestTunnelResponse {
    #[serde(rename = "ipv4")]
    pub ipv4: String,
    #[serde(rename = "publicKey")]
    pub public_key: String,
    pub peers: Vec<Peer>,
}

#[derive(Deserialize, Debug)]
pub struct RemovePeer {
    #[serde(rename = "userId")]
    pub user_id: String,
}

#[derive(Deserialize, Debug)]
pub struct NodeMessageType {
    pub r#type: u8,
}

#[derive(Deserialize, Serialize, Debug)]
pub struct NodeMessage<T> {
    pub r#type: u8,
    pub body: T,
}
#[derive(Serialize, Deserialize, Debug)]
pub struct WireguardInterface {
    #[serde(rename = "PrivateKey")]
    pub private_key: String,
    #[serde(rename = "Address")]
    pub address: String,
    #[serde(rename = "ListenPort")]
    pub listen_port: u16,
    #[serde(rename = "PostUp")]
    pub post_up: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct WireguardConf {
    #[serde(rename = "Interface")]
    pub(crate) interface: WireguardInterface,
}

impl WireguardConf {
    pub fn get_private_key(config: &Config) -> Result<String, Box<dyn std::error::Error>> {
        let config_path =
            Path::new(&config.node.conf_dir).join(format!("{}.conf", config.node.wg_interface));
        debug!("Loading config from: {:?}", config_path);

        let contents = match fs::read_to_string(config_path) {
            Ok(c) => c,
            Err(e) => {
                debug!("{}", format!("Unable to retrieve Wireguard config: {e}"));
                return Err(format!("Unable to retrieve Wireguard config: {e}").into());
            }
        };

        let config = match WireguardConf::deserialize(&mut Deserializer::new(Parser::from_str(
            &contents.as_str(),
        ))) {
            Ok(d) => d,
            Err(e) => {
                eprintln!("{}", e);
                return Err(format!("Unable to parse Wireguard config: {e}").into());
            }
        };

        Ok(config.interface.private_key)
    }
}

impl Display for WireguardConf {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        let wg_conf = serde_ini::to_string(&self).unwrap();
        let conf_prefix =
            "# Note: Do not edit this file directly.\n# Your changes will be overwritten!";
        write!(f, "{}\n\n{}", conf_prefix, wg_conf)
    }
}
